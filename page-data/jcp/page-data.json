{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/jcp/","result":{"data":{"site":{"siteMetadata":{"title":"Persistence","social":[{"name":"github","url":"https://github.com/gatsbyjs"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"id":"10799be3-ac25-5756-ae42-28296f1fbcd3","excerpt":"Counting duplicate characters 首先會先想到利用  map  來記數，個別單字出現的次數。 完全利用 Java 8 lambda 的方法撰寫 須要注意到  str.chars()  回傳為  IntStream  及  mapToObj…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Java Coding Problem Ch1.\",\n  \"date\": \"2021-06-10T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Counting duplicate characters\"), mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\\u9996\\u5148\\u6703\\u5148\\u60F3\\u5230\\u5229\\u7528 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" \\u4F86\\u8A18\\u6578\\uFF0C\\u500B\\u5225\\u55AE\\u5B57\\u51FA\\u73FE\\u7684\\u6B21\\u6578\\u3002\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public Map<Character, Integer> countDuplicateCharacters(String str) {  \\n    Map<Character, Integer> result = new HashMap<>();  \\n\\n    // or use for(char ch: str.toCharArray()) { ... }  \\n    for (int i = 0; i<str.length(); i++) {    \\n        char ch = str.charAt(i);     \\n        result.compute(ch, (k, v) -> (v == null) ? 1 : ++v);  \\n    }  \\n\\n    return result;\\n}\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\\u5B8C\\u5168\\u5229\\u7528 Java 8 lambda \\u7684\\u65B9\\u6CD5\\u64B0\\u5BEB\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public Map<Character, Long> countDuplicateCharacters(String str) {  \\n    Map<Character, Long> result = str.chars()    \\n        .mapToObj(c -> (char) c)    \\n        .collect(Collectors.groupingBy(c -> c, Collectors.counting()));  \\n    \\n    return result;\\n}\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\\u9808\\u8981\\u6CE8\\u610F\\u5230 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"str.chars()\"), \" \\u56DE\\u50B3\\u70BA \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IntStream\"), \" \\u53CA \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mapToObj\"), \" \\u8F49\\u63DB\\u81F3 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"char \\u578B\\u614B\"), \"\\nlambda \\u4F7F\\u7528\\u65B9\\u6CD5\\u672A\\u5230\\u9019\\u9EBC\\u719F\\u7DF4\\u9084\\u6C92\\u8FA6\\u6CD5\\u5728\\u7B2C\\u4E00\\u6642\\u9593\\u5167\\u5BEB\\u51FA\\u4F86\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\\u6B64\\u554F\\u984C\\u771F\\u7684\\u8981\\u6CE8\\u610F\\u5230\\u7684\\u5176\\u5BE6\\u662F \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \" \\u6240\\u5B58\\u7684\\u7DE8\\u78BC\\u65B9\\u5F0F\\u70BA \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ASCII\"), \" \\u6216\\u662F \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UnicodeASCII\"), \" \\u662F\\u5176\\u5BE6\\u662F\\u4ECB\\u65BC 32-127 \\u4E4B\\u9593\\u7684 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \" \\u6578\\u503C\\u6216\\u662F \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"extended ASCII\"), \" \\u4ECB\\u65BC 128-255\\u3002\\n\\u6BD4\\u8F03\\u5C11\\u8A0E\\u8AD6\\u7684\\u662F \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Unicode\"), \" \\uFF0C\\u9019\\u908A\\u5148\\u8DF3\\u904E\\u6709\\u7A7A\\u56DE\\u4F86\\u88DC\\u2026\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Finding the first non-repeated character\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  \\u627E\\u51FA\\u5B57\\u4E32\\u4E2D\\u7B2C\\u4E00\\u500B\\u4E0D\\u91CD\\u8907\\u7684\\u5B57\\u5143\\u3002\\n\\u7B2C\\u4E00\\u500B\\u60F3\\u5230\\u7684\\u505A\\u6CD5\\u662F\\u5229\\u7528 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LinkedHashMap\"), \" \\u6703\\u4FDD\\u6301 key \\u65B0\\u589E\\u7684\\u9806\\u5E8F\\u7279\\u6027\\u4F86\\u67E5\\u627E\\u3002\\n\\u6BD4\\u8F03\\u63A5\\u8FD1\\u66F8\\u4E0A\\u7B2C\\u4E8C\\u7A2E\\u7684\\u505A\\u6CD5\\uFF0C\\u5DEE\\u5728\\u4E2D\\u9593\\u6C92\\u60F3\\u5230\\u5229\\u7528 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"chars.compute(ch, (k, v) -> (v == null) ? 1 : ++v);\"), \"\\n\\u7522\\u751F\\u8F03\\u70BA\\u7C21\\u6F54\\u7684\\u505A\\u6CD5\\u3002\"), mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\\u5E38\\u898F\\u505A\\u6CD5\\u90FD\\u5148\\u5047\\u5B9A\\u5B57\\u5143\\u70BA \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ASCII\"), \" \\uFF08256 \\u7A2E\\uFF09\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Unicode\"), \" \\u4E4B\\u5F8C\\u8A0E\\u8AD6\\n\\uFF0C\\u5EFA\\u9663\\u5217\\u7D00\\u9304\\u5B57\\u5143\\u51FA\\u73FE\\u7684\\u6B21\\u6578\\u3002\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"private static final int EXTENDED_ASCII_CODES = 256;\\n\\npublic char firstNonRepeatedCharacter(String str) {  \\n    int[] flags = new int[EXTENDED_ASCII_CODES];\\n\\n    // init to -1\\n    // can use Arrays.fill(flags, -1); instead  \\n    for (int i = 0; i < flags.length; i++) {    \\n       flags[i] = -1;  \\n    }\\n\\n    for (int i = 0; i < str.length(); i++) {\\n        char ch = str.charAt(i);\\n        if (flags[ch] == -1) {\\n            flags[ch] = i;\\n        } else {\\n            flags[ch] = -2;\\n        }\\n    }\\n\\n    int position = Integer.MAX_VALUE;\\n    for (int i = 0; i < EXTENDED_ASCII_CODES; i++) {\\n        if (flags[i] >= 0) {\\n            position = Math.min(position, flags[i]);\\n        }\\n    }\\n    return position == Integer.MAX_VALUE ?\\n    Character.MIN_VALUE : str.charAt(position);\\n}\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LinkedHashMap\"), \" \"), mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This Java map is an insertion-order map (it maintains the order in which the keys were inserted into the map) and is very convenient for this solution.\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public char firstNonRepeatedCharacter(String str) {\\n  Map<Character, Integer> chars = new LinkedHashMap<>();\\n  // or use for(char ch: str.toCharArray()) { ... }\\n\\n  for (int i = 0; i < str.length(); i++) {\\n    char ch = str.charAt(i);\\n    chars.compute(ch, (k, v) -> (v == null) ? 1 : ++v);\\n  }\\n\\n  for (Map.Entry<Character, Integer> entry: chars.entrySet()) {\\n    if (entry.getValue() == 1) {\\n      return entry.getKey();\\n    }\\n  }\\n  return Character.MIN_VALUE;\\n}\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\\u6700\\u5F8C\\u4E00\\u7A2E\\u517C\\u5177\\u8655\\u7406 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ASCII\"), \" \\u548C \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Unicode\"), \" \\u4E14\\u7528 lambda \\u65B9\\u5F0F\\n\\u5BE6\\u6230\\u4E0A\\u9084\\u662F\\u6C92\\u719F\\u7DF4\\u5230\\u80FD\\u76F4\\u63A5\\u5BEB\\u51FA\\u4F86;;\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public static String firstNonRepeatedCharacter(String str) {\\n\\nMap<Integer, Long> chs = str.codePoints()\\n                            .mapToObj(cp -> cp)\\n                            .collect(Collectors.groupingBy(Function.identity(),\\nLinkedHashMap::new, Collectors.counting()));\\n\\nint cp = chs.entrySet().stream()\\n                        .filter(e -> e.getValue() == 1L)\\n                        .findFirst()\\n                        .map(Map.Entry::getKey)\\n                        .orElse(Integer.valueOf(Character.MIN_VALUE));\\n\\nreturn String.valueOf(Character.toChars(cp));\\n}\\n\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Reversing letters and words\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  \\u53CD\\u8F49\\u53E5\\u5B50\\u4E2D\\u6BCF\\u500B\\u55AE\\u5B57\\uFF0C\\u300C\\u53EA\\u6709\\u55AE\\u5B57\\u5B57\\u6BCD\\u7684\\u9806\\u5E8F\\u300D\\u3002\"), mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Notice that the preceding two methods return a string containing the letters of each word reversed, but the words themselves are in the same initial order.\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"private static final Pattern PATTERN = Pattern.compile(\\\" +\\\");\\n...\\npublic static String reverseWords(String str) {\\n\\n  return PATTERN.splitAsStream(str)\\n    .map(w -> new StringBuilder(w).reverse())\\n    .collect(Collectors.joining(\\\" \\\"));\\n}\\n\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public String reverse(String str) {\\n\\n  return new StringBuilder(str).reverse().toString();\\n}\\n\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Checking whether a string contains only digits\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Character.isDigit()\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String.matches()\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public static boolean containsOnlyDigits(String str) {\\n\\n  return !str.chars()\\n    .anyMatch(n -> !Character.isDigit(n));\\n}\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Notice that Java 8 functional style and regular expression-based solutions are usually slow, so if speed is a requirement, then it\\u2019s better to rely on the first solution using Character.isDigit().\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public static boolean containsOnlyDigits(String str) {\\n\\n  for (int i = 0; i < str.length(); i++) {\\n    if (!Character.isDigit(str.charAt(i))) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n\")), mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Avoid solving this problem via parseInt() or parseLong(). First of all, it\\u2019s bad practice to catch NumberFormatException and take business logic decisions in the catch block. Second, these methods verify whether the string is a valid number, not whether it contains only digits (for example, -4 is valid).\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Counting vowels and consonants\"), mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\\u7528 partioningBy \\u5C07 true false \\u5207\\u958B\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\\u7528 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Pair<>\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"Map<Boolean, Long> result = str.chars()\\n  .mapToObj(c -> (char) c)\\n  .filter(ch -> (ch >= 'a' && ch <= 'z'))\\n  .collect(partitioningBy(c -> allVowels.contains(c), counting()));\\n\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"private static final Set<Character> allVowels\\n            = new HashSet(Arrays.asList('a', 'e', 'i', 'o', 'u'));\\n\\npublic static Pair<Long, Long> countVowelsAndConsonants(String str) {\\n\\n  str = str.toLowerCase();\\n\\n  long vowels = str.chars()\\n    .filter(c -> allVowels.contains((char) c))\\n    .count();\\n\\n  long consonants = str.chars()\\n    .filter(c -> !allVowels.contains((char) c))\\n    .filter(ch -> (ch >= 'a' && ch<= 'z'))\\n    .count();\\n\\n  return Pair.of(vowels, consonants);\\n}\\n\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Counting the occurrences of a certain character (u)\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  \\u7570\\u60F3\\u4E0D\\u5230\\u7684\\u65B9\\u6CD5\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public static int countOccurrencesOfACertainCharacter(\\n    String str, char ch) {\\n\\n  return str.length() - str.replace(String.valueOf(ch), \\\"\\\").length();\\n}\\n\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public static long countOccurrencesOfACertainCharacter(\\n    String str, char ch) {\\n\\n  return str.chars()\\n    .filter(c -> c == ch)\\n    .count();\\n}\\n\")), mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"For third-party library support, please consider Apache Commons Lang, StringUtils.countMatches(), Spring Framework, StringUtils.countOccurrencesOf(), and Guava, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://charmatcher.is/\"\n  }, \"CharMatcher.is\"), \"().countIn().\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Converting a string into an int, long, float, or double\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  \\u89C0\\u5FF5\\u7528\\u6CD5\\uFF0C\\u5B57\\u4E32\\u8F49 primitive type \\u6216\\u662F boxed type\\uFF0C\\nxxx. parseXXX() -> \\u8F49\\u6210\\u539F\\u59CB\\u578B\\u614B\\nxxx.valueOf() -> \\u8F49\\u6210\\u7269\\u4EF6\\u578B\\u614B\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"int toInt = Integer.parseInt(TO_INT);\\nlong toLong = Long.parseLong(TO_LONG);\\nfloat toFloat = Float.parseFloat(TO_FLOAT);\\ndouble toDouble = Double.parseDouble(TO_DOUBLE);\\n\\n//\\n\\nInteger toInt = Integer.valueOf(TO_INT);\\nLong toLong = Long.valueOf(TO_LONG);\\nFloat toFloat = Float.valueOf(TO_FLOAT);\\nDouble toDouble = Double.valueOf(TO_DOUBLE);\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  While parsing fail, both parseXXX and valueOf methods will throw \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NumberFormatException\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"private static final String WRONG_NUMBER = \\\"452w\\\";\\n\\ntry {\\n  Integer toIntWrong1 = Integer.valueOf(WRONG_NUMBER);\\n} catch (NumberFormatException e) {\\n  System.err.println(e);\\n  // handle exception\\n}\\n\\ntry {\\n  int toIntWrong2 = Integer.parseInt(WRONG_NUMBER);\\n} catch (NumberFormatException e) {\\n  System.err.println(e);\\n  // handle exception\\n}\\n\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Removing white spaces from a string\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public static String removeWhitespaces(String str) {\\n  return str.replaceAll(\\\"\\\\\\\\s\\\", \\\"\\\");\\n}\\n\")), mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"For third-party library support, please consider Apache Commons Lang, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StringUtils.deleteWhitespace()\"), \", and the Spring Framework, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StringUtils.trimAllWhitespace()\"), \".\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Joining multiple strings with a delimiter\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  \\u7B97\\u662F\\u975E\\u5E38\\u5E38\\u898B\\u7684\\u554F\\u984C\\uFF0C\\u5728\\u5F8C\\u7AEF\\u5E38\\u9047\\u5230\\u7684\\u5C31\\u662F\\u8981\\u7D44\\u8A9E\\u6CD5 X or X or X or \\u2026\\u3002\\n\\u5957\\u7528 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StringBuilder\"), \"  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"append()\"), \" \\u7B97\\u662F\\u6700\\u76F4\\u89C0\\u7684\\u60F3\\u6CD5\\uFF0C\\n\\u4E0D\\u904E\\u6BCF\\u6B21\\u9047\\u5230\\u6700\\u5F8C\\u4E00\\u500B\\u90FD\\u8981\\u53E6\\u5916\\u8655\\u7406\\u4EE4\\u4EBA\\u4E0D\\u5FEB\\u3002\"), mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StringBuilder\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public static String joinByDelimiter(char delimiter, String...args) {\\n\\n  StringBuilder result = new StringBuilder();\\n\\n  int i = 0;\\n  for (i = 0; i < args.length - 1; i++) {\\n    result.append(args[i]).append(delimiter);\\n  }\\n  result.append(args[i]);\\n\\n  return result.toString();\\n}\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StringJoiner\"), \" from Java 8\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public static String joinByDelimiter(char delimiter, String...args) {\\n  StringJoiner joiner = new StringJoiner(String.valueOf(delimiter));\\n\\n  for (String arg: args) {\\n    joiner.add(arg);\\n  }\\n\\n  return joiner.toString();\\n}\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"or another \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String.join()\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"String join(CharSequence delimiter, CharSequence... elems)\\nString join(CharSequence delimiter,\\n  Iterable<? extends CharSequence> elems)\\n\\nString result = String.join(\\\" \\\", \\\"how\\\", \\\"are\\\", \\\"you\\\"); // how are you\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Collectors.joining()\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public static String joinByDelimiter(char delimiter, String...args) {\\n  return Arrays.stream(args, 0, args.length)\\n    .collect(Collectors.joining(String.valueOf(delimiter)));\\n}\\n\")))))));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/jcp/","title":"Java Coding Problem Ch1.","tags":[],"date":"June 10, 2021","image":null,"imageAlt":null,"imageCaptionText":null,"imageCaptionLink":null,"socialImage":null},"previous":{"id":"5388ce71-a3df-52c7-99eb-e6e53560b065","excerpt":"Wow! I love blogging so much already. Did you know that \"despite its name, salted duck eggs can also be made from chicken eggs, though the…","slug":"/my-second-post/","title":"My Second Post! (example)","date":"May 15, 2019"},"next":{"id":"a76771bc-2894-5260-942c-288eb9d85675","excerpt":"冠狀病毒解碼 疫苗競賽 名詞解釋 病毒是什麼？具象化來說病毒只是一個載體，上面搭載了如何生成更多病毒的方法，當它進入細胞後會開始命令細胞產生更多病毒。 antigen…","slug":"/coronavirous_explained_vol2/","title":"Coronavirous Expained Vol2","date":"June 11, 2021"}},"pageContext":{"id":"10799be3-ac25-5756-ae42-28296f1fbcd3","previousId":"5388ce71-a3df-52c7-99eb-e6e53560b065","nextId":"a76771bc-2894-5260-942c-288eb9d85675","maxWidth":1380}},"staticQueryHashes":["2744905544","3090755652","3308536712","764694655"]}